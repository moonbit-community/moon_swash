// Generated using `moon info`, DON'T EDIT IT
package "Milky2018/moon_swash/shape"

import {
  "Milky2018/moon_swash",
  "Milky2018/moon_swash/internal",
}

// Values
pub const COMPONENT : UInt16 = 4

pub const CURSIVE_ATTACH : UInt16 = 16

pub const IGNORABLE : UInt16 = 64

pub const LIGATED : UInt16 = 2

pub const MARK_ATTACH : UInt16 = 8

pub const MAX_CLUSTER_SIZE : Int = 32

pub const SUBSTITUTED : UInt16 = 1

pub fn apply(Byte, Bytes, UInt, ArrayView[Int], @internal.Gdef, Storage, FeatureStore, FeatureMask, Buffer, IndexRange?) -> Bool?

pub fn feature_bit_to_mask(UInt16?) -> FeatureMask

pub fn reorder_complex(Array[GlyphData], Array[GlyphData], Array[Int]) -> Unit

pub fn reorder_myanmar(ArrayView[@moon_swash.ClusterChar], Array[Int]) -> Unit

pub fn[S : Selector, O : ShapeOptions] shape(ShapeContext, S, O, Iter[@moon_swash.Token], (SelectedFont, Shaper) -> Unit) -> Unit

// Errors

// Types and methods
type ApplyContext

type BitSet

pub struct Buffer {
  glyphs : Array[GlyphData]
  positions : Array[PositionData]
  infos : Array[(@moon_swash.ClusterInfo, Bool, UInt)]
  ranges : Array[@moon_swash.SourceRange]
  shaped_glyphs : Array[Glyph]
  mut is_rtl : Bool
  mut dotted_circle : UInt16?
  mut has_cursive : Bool
  mut has_marks : Bool
  mut reversed : Bool
  mut next_cluster : UInt
  mut skip_state : SkipState
  sub_args : Array[UInt16]
  pos_args : Array[UInt16]
}
pub fn Buffer::_push_hangul(Self, @moon_swash.CharCluster) -> IndexRange
pub fn Buffer::clear(Self) -> Unit
pub fn Buffer::clear_flags(Self, UInt16, IndexRange?) -> Unit
pub fn Buffer::default() -> Self
pub fn Buffer::ensure_order(Self, Bool) -> Unit
pub fn Buffer::glyphs(Self) -> ArrayView[GlyphData]
pub fn Buffer::len(Self) -> Int
pub fn Buffer::multiply(Self, Int, Int) -> Unit
pub fn Buffer::new() -> Self
pub fn Buffer::position(Self, Int, Double, Double, Double, Double) -> Unit
pub fn Buffer::position_cursive(Self, Int, Int, Double, Double) -> Unit
pub fn Buffer::position_mark(Self, Int, Int, Double, Double) -> Unit
pub fn Buffer::positions(Self) -> ArrayView[PositionData]
pub fn Buffer::push(Self, @moon_swash.CharCluster) -> IndexRange
pub fn Buffer::push_order(Self, @moon_swash.CharCluster, ArrayView[Int]) -> IndexRange
pub fn Buffer::ranges(Self) -> ArrayView[@moon_swash.SourceRange]
pub fn Buffer::set_join_masks(Self) -> Unit
pub fn Buffer::setup_positions(Self, Bool) -> Unit
pub fn Buffer::substitute(Self, Int, UInt16) -> Unit
pub fn Buffer::substitute_ligature(Self, Int, UInt16, ArrayView[Int]) -> Unit
pub fn Buffer::substitute_multiple(Self, Int, ArrayView[UInt16]) -> Unit

type ContextState

type CoverageBuilder

pub(all) enum Direction {
  LeftToRight
  RightToLeft
}
pub impl Eq for Direction

pub struct Engine {
  data : Bytes
  gdef : @internal.Gdef
  gsub : StageOffsets
  gpos : StageOffsets
  morx : UInt
  kerx : UInt
  ankr : UInt
  kern : UInt
  storage : Storage
  coords : ArrayView[Int]
  script : @moon_swash.Script
  tags : (UInt, UInt, UInt, UInt)
  sub_mode : SubMode
  pos_mode : PosMode
  use_ot : Bool
  mode : EngineMode
}
pub fn Engine::collect_features(Self, FeatureStoreBuilder, Ref[FeatureStore]) -> Unit
pub fn Engine::gpos(Self, FeatureStore, FeatureMask, Buffer, IndexRange?) -> Bool
pub fn Engine::gsub(Self, FeatureStore, FeatureMask, Buffer, IndexRange?) -> Bool
pub fn Engine::has_feature_vars(Self) -> Bool
pub fn Engine::new(EngineMetadata, Bytes, ArrayView[Int], @moon_swash.Script, @moon_swash.Language?) -> Self
pub fn Engine::set_classes(Self, Buffer, IndexRange?) -> Unit
pub fn Engine::tags(Self) -> (UInt, UInt, UInt, UInt)

pub struct EngineMetadata {
  gdef : UInt
  gsub : UInt
  gpos : UInt
  morx : UInt
  kerx : UInt
  ankr : UInt
  kern : UInt
  sub_mode : SubMode
  pos_mode : PosMode
}
pub fn EngineMetadata::from_font(@moon_swash.FontRef) -> Self

pub(all) enum EngineMode {
  Simple
  Myanmar
  Complex
}
pub impl Eq for EngineMode

type FeatureCache

type FeatureCacheEntry

pub struct FeatureGroups {
  default : FeatureMask
  mut reph : UInt16?
  mut pref : UInt16?
  stage1 : FeatureMask
  stage2 : FeatureMask
  basic : FeatureMask
  position : FeatureMask
  vert : FeatureMask
  rtl : FeatureMask
}
pub fn FeatureGroups::default() -> Self

pub struct FeatureMask {
  mut b0 : UInt64
  mut b1 : UInt64
  mut b2 : UInt64
  mut b3 : UInt64
}
pub fn FeatureMask::clear(Self, UInt16) -> Unit
pub fn FeatureMask::default() -> Self
pub fn FeatureMask::has(Self, UInt16) -> Bool
pub fn FeatureMask::is_empty(Self) -> Bool
pub fn FeatureMask::or(Self, Self) -> Self
pub fn FeatureMask::or_assign(Self, Self) -> Unit
pub fn FeatureMask::set(Self, UInt16) -> Unit

pub struct FeatureStore {
  sub_features : Array[(UInt, UInt16)]
  pos_features : Array[(UInt, UInt16)]
  lookups : Array[@internal.LookupData]
  subtables : Array[@internal.SubtableData]
  coverage : Array[UInt16]
  mut pos_start : Int
  mut sub_count : Int
  mut truncated : Bool
  mut groups : FeatureGroups
}
pub fn FeatureStore::clear(Self) -> Unit
pub fn FeatureStore::custom_masks(Self, ArrayView[@moon_swash.Setting[UInt16]], Array[UInt16], Array[UInt16], Direction) -> (FeatureMask, FeatureMask)
pub fn FeatureStore::default() -> Self
pub fn FeatureStore::groups(Self, @moon_swash.Script) -> FeatureGroups
pub fn FeatureStore::pos_bit(Self, UInt) -> UInt16?
pub fn FeatureStore::sub_bit(Self, UInt) -> UInt16?

pub struct FeatureStoreBuilder {
  indices : Array[(UInt16, UInt16, Byte)]
  coverage : CoverageBuilder
  mut next_bit : UInt16
}
pub fn FeatureStoreBuilder::build(Self, Ref[FeatureStore], Bytes, ArrayView[Int], @internal.Gdef, StageOffsets, StageOffsets) -> Unit
pub fn FeatureStoreBuilder::default() -> Self

pub struct FontEntry {
  metrics : @moon_swash.MetricsProxy
  charmap : @moon_swash.CharmapProxy
  coord_count : UInt16
  metadata : EngineMetadata
}
pub fn FontEntry::new(@moon_swash.FontRef) -> Self

pub struct Glyph {
  id : UInt16
  info : GlyphInfo
  x : Double
  y : Double
  advance : Double
  data : UInt
}
pub fn Glyph::advance(Self) -> Double
pub fn Glyph::data(Self) -> UInt
pub fn Glyph::default() -> Self
pub fn Glyph::id(Self) -> UInt16
pub fn Glyph::info(Self) -> GlyphInfo
pub fn Glyph::x(Self) -> Double
pub fn Glyph::y(Self) -> Double

pub struct GlyphCluster {
  source : @moon_swash.SourceRange
  info : @moon_swash.ClusterInfo
  glyphs : ArrayView[Glyph]
  components : ArrayView[@moon_swash.SourceRange]
  data : UInt
}
pub fn GlyphCluster::advance(Self) -> Double
pub fn GlyphCluster::components(Self) -> ArrayView[@moon_swash.SourceRange]
pub fn GlyphCluster::data(Self) -> UInt
pub fn GlyphCluster::glyphs(Self) -> ArrayView[Glyph]
pub fn GlyphCluster::info(Self) -> @moon_swash.ClusterInfo
pub fn GlyphCluster::is_complex(Self) -> Bool
pub fn GlyphCluster::is_empty(Self) -> Bool
pub fn GlyphCluster::is_ligature(Self) -> Bool
pub fn GlyphCluster::is_simple(Self) -> Bool
pub fn GlyphCluster::source(Self) -> @moon_swash.SourceRange

pub struct GlyphData {
  mut id : UInt16
  mut flags : UInt16
  mut class : Byte
  mut char_class : @moon_swash.ShapeClass
  mut mark_type : Byte
  joining_type : Byte
  mut mask : Byte
  mut skip : Bool
  mut component : Byte
  mut cluster : UInt
  data : UInt
}
pub fn GlyphData::cluster(Self) -> UInt
pub fn GlyphData::default() -> Self
pub fn GlyphData::flags(Self) -> UInt16
pub fn GlyphData::id(Self) -> UInt16
pub fn GlyphData::is_component(Self) -> Bool

pub struct GlyphInfo {
  bits : UInt16
}
pub fn GlyphInfo::default() -> Self
pub fn GlyphInfo::is_mark(Self) -> Bool
pub fn GlyphInfo::new(UInt16) -> Self

pub struct IndexRange {
  start : Int
  end : Int
}
pub fn IndexRange::end(Self) -> Int
pub fn IndexRange::new(Int, Int) -> Self
pub fn IndexRange::start(Self) -> Int

type LookupState

type Pos4

pub(all) enum PosMode {
  None
  Gpos
  Kerx
  Kern
}
pub impl Eq for PosMode

pub struct PositionData {
  mut base : Byte
  mut flags : UInt16
  mut x : Double
  mut y : Double
  mut advance : Double
}
pub fn PositionData::default() -> Self

pub struct SelectedFont {
  font : @moon_swash.FontRef
  id_override : (UInt64, UInt64)?
  synthesis : @moon_swash.Synthesis?
}
pub fn SelectedFont::font(Self) -> @moon_swash.FontRef
pub fn SelectedFont::id_override(Self) -> (UInt64, UInt64)?
pub fn SelectedFont::new(@moon_swash.FontRef) -> Self
pub fn SelectedFont::synthesis(Self) -> @moon_swash.Synthesis?
pub fn SelectedFont::with_id_override(Self, (UInt64, UInt64)) -> Self
pub fn SelectedFont::with_synthesis(Self, @moon_swash.Synthesis) -> Self

pub struct ShapeContext {
  inner : Ref[ContextState]
}
pub fn ShapeContext::builder(Self, @moon_swash.FontRef) -> ShaperBuilder
pub fn ShapeContext::builder_with_id(Self, @moon_swash.FontRef, (UInt64, UInt64)) -> ShaperBuilder
pub fn ShapeContext::new() -> Self
pub fn ShapeContext::with_max_entries(Int) -> Self

pub struct Shaper {
  cx : Ref[ContextState]
  font : @moon_swash.FontRef
  id0 : UInt64
  id1 : UInt64
  font_entry : Ref[FontEntry]
  charmap : @moon_swash.Charmap
  size : Double
  script : @moon_swash.Script
  language : @moon_swash.Language?
  direction : Direction
  retain_ignorables : Bool
  joined : Bool
  engine : Engine
  store : Ref[FeatureStore]?
  sub_mask : FeatureMask
  pos_mask : FeatureMask
}
pub fn Shaper::add_cluster(Self, @moon_swash.CharCluster) -> Unit
pub fn Shaper::add_str(Self, String) -> Unit
pub fn Shaper::metrics(Self) -> @moon_swash.Metrics
pub fn Shaper::normalized_coords(Self) -> ArrayView[Int]
pub fn Shaper::shape_with(Self, (GlyphCluster) -> Unit) -> Unit

pub struct ShaperBuilder {
  cx : Ref[ContextState]
  font : @moon_swash.FontRef
  id0 : UInt64
  id1 : UInt64
  size : Double
  script : @moon_swash.Script
  language : @moon_swash.Language?
  direction : Direction
  font_entry : Ref[FontEntry]
  charmap : @moon_swash.Charmap
  dotted_circle : UInt16?
  retain_ignorables : Bool
}
pub fn ShaperBuilder::build(Self) -> Shaper
pub fn ShaperBuilder::direction(Self, Direction) -> Self
pub fn ShaperBuilder::features(Self, Iter[@moon_swash.Setting[UInt16]]) -> Self
pub fn ShaperBuilder::insert_dotted_circles(Self, Bool) -> Self
pub fn ShaperBuilder::language(Self, @moon_swash.Language?) -> Self
pub fn ShaperBuilder::retain_ignorables(Self, Bool) -> Self
pub fn ShaperBuilder::script(Self, @moon_swash.Script) -> Self
pub fn ShaperBuilder::size(Self, Double) -> Self
pub fn ShaperBuilder::variations(Self, Iter[@moon_swash.Setting[Double]]) -> Self

pub struct SimpleShapeOptions {
  script : @moon_swash.Script
  language : @moon_swash.Language?
  direction : Direction
  size : Double
  features : Array[@moon_swash.Setting[UInt16]]
  variations : Array[@moon_swash.Setting[Double]]
  insert_dotted_circles : Bool
}
pub fn SimpleShapeOptions::default() -> Self
pub impl ShapeOptions for SimpleShapeOptions

pub struct SkipState {
  flags : Byte
  mask : Byte
  mark_check : Byte
  mark_class : Byte
  mark_set : UInt
}
pub fn SkipState::default() -> Self

pub struct StageOffsets {
  base : UInt
  lang : UInt
  vars : UInt
}
pub fn StageOffsets::default() -> Self
pub fn StageOffsets::new(Bytes, UInt, UInt, UInt?) -> (Self, (UInt, UInt))?

type State

pub struct Storage {
  stack : Array[LookupState]
  ids : Array[UInt16]
  indices : Array[Int]
}
pub fn Storage::default() -> Self

pub(all) enum SubMode {
  None
  Gsub
  Morx
}
pub impl Eq for SubMode

// Type aliases
pub using @moon_swash {type CharCluster}

pub using @moon_swash {type ClusterChar}

pub using @moon_swash {type ClusterInfo}

pub type Epoch = UInt64

pub type FeatureBit = UInt16

pub type GlyphId = UInt16

pub using @moon_swash {type JoiningType}

pub using @moon_swash {type ShapeClass}

pub using @moon_swash {type SourceRange}

pub type Tag = UInt

pub type UserData = UInt

// Traits
pub(open) trait Selector {
  select_font(Self, @moon_swash.CharCluster) -> SelectedFont?
}

pub(open) trait ShapeOptions {
  script(Self) -> @moon_swash.Script
  language(Self) -> @moon_swash.Language?
  direction(Self) -> Direction
  size(Self) -> Double
  features(Self) -> Iter[@moon_swash.Setting[UInt16]]
  variations(Self) -> Iter[@moon_swash.Setting[Double]]
  insert_dotted_circles(Self) -> Bool
}

