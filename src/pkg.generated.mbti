// Generated using `moon info`, DON'T EDIT IT
package "Milky2018/moon_swash"

import {
  "Milky2018/moon_swash/internal",
}

// Values
pub const COMPOSE1_COUNT : Int = 63

pub const MAX_CLUSTER_SIZE : Int = 32

pub const UNICODE_VERSION_MAJOR : Int = 13

pub const UNICODE_VERSION_MINOR : Int = 0

pub const UNICODE_VERSION_PATCH : Int = 0

pub fn analyze(Iter[Char]) -> Analyze

pub fn compose_pair(Char, Char) -> Char?

pub fn decompose(Char) -> Iter[Char]

pub fn decompose_compat(Char) -> Iter[Char]

pub fn desc_from_aat(UInt16, UInt16) -> (Int, UInt, String)?

pub fn desc_from_at(UInt) -> (Int, String)?

pub fn tag_from_bytes(Bytes) -> UInt?

pub fn tag_from_str_lossy(String) -> UInt

pub fn unicode_version() -> (Int, Int, Int)

// Errors

// Types and methods
pub(all) enum Action {
  Substitution
  Attachment
  Adjustment
}

pub struct Analyze {
  chars : CharStream
  state : BoundaryState
}
pub fn Analyze::iter(Self) -> Iter[(Properties, Boundary)]
pub fn Analyze::needs_bidi_resolution(Self) -> Bool
pub fn Analyze::next(Self) -> (Properties, Boundary)?
pub fn Analyze::set_break_strength(Self, WordBreakStrength) -> Unit

pub struct Attributes {
  value : UInt
}
pub fn Attributes::from_font(FontRef) -> Self
pub fn Attributes::has_italic_variation(Self) -> Bool
pub fn Attributes::has_oblique_variation(Self) -> Bool
pub fn Attributes::has_stretch_variation(Self) -> Bool
pub fn Attributes::has_variations(Self) -> Bool
pub fn Attributes::has_weight_variation(Self) -> Bool
pub fn Attributes::new(Stretch, Weight, Style) -> Self
pub fn Attributes::parts(Self) -> (Stretch, Weight, Style)
pub fn Attributes::stretch(Self) -> Stretch
pub fn Attributes::style(Self) -> Style
pub fn Attributes::synthesize(Self, Self) -> Synthesis
pub fn Attributes::weight(Self) -> Weight
pub impl Eq for Attributes
pub impl Show for Attributes

pub(all) enum BidiClass {
  AL
  AN
  B
  BN
  CS
  EN
  ES
  ET
  FSI
  L
  LRE
  LRI
  LRO
  NSM
  ON
  PDF
  PDI
  R
  RLE
  RLI
  RLO
  S
  WS
}
pub fn BidiClass::needs_resolution(Self) -> Bool

pub struct BitmapStrike {
  b : @internal.BeBytes
  bitmap_data : BytesView
  offset : Int
  upem : UInt
  is_sbix : Bool
  is_apple : Bool
}
pub fn BitmapStrike::bit_depth(Self) -> Byte
pub fn BitmapStrike::contains(Self, UInt16) -> Bool
pub fn BitmapStrike::ppem(Self) -> UInt16
pub fn BitmapStrike::ppi(Self) -> UInt16

pub struct BitmapStrikes {
  b : @internal.BeBytes
  bitmap_data : BytesView
  is_sbix : Bool
  is_apple : Bool
  upem : UInt
  len : Int
}
pub fn BitmapStrikes::find_by_exact_ppem(Self, UInt16, UInt16) -> BitmapStrike?
pub fn BitmapStrikes::find_by_largest_ppem(Self, UInt16) -> BitmapStrike?
pub fn BitmapStrikes::find_by_nearest_ppem(Self, UInt16, UInt16) -> BitmapStrike?
pub fn BitmapStrikes::iter(Self) -> Iter[BitmapStrike]
pub fn BitmapStrikes::len(Self) -> Int

pub struct BitmapStrikesProxy {
  bitmaps : (UInt, UInt)
  color_bitmaps : (UInt, UInt)
  upem : UInt
  is_apple : Bool
}
pub fn BitmapStrikesProxy::from_font(FontRef) -> Self
pub fn BitmapStrikesProxy::has_alpha(Self) -> Bool
pub fn BitmapStrikesProxy::has_color(Self) -> Bool
pub fn BitmapStrikesProxy::materialize_alpha(Self, FontRef) -> BitmapStrikes
pub fn BitmapStrikesProxy::materialize_color(Self, FontRef) -> BitmapStrikes

pub(all) enum Block {
  Adlam
  AegeanNumbers
  Ahom
  AlchemicalSymbols
  AlphabeticPresentationForms
  AnatolianHieroglyphs
  AncientGreekMusicalNotation
  AncientGreekNumbers
  AncientSymbols
  Arabic
  ArabicExtendedA
  ArabicMathematicalAlphabeticSymbols
  ArabicPresentationFormsA
  ArabicPresentationFormsB
  ArabicSupplement
  Armenian
  Arrows
  BasicLatin
  Avestan
  Balinese
  Bamum
  BamumSupplement
  BassaVah
  Batak
  Bengali
  Bhaiksuki
  BlockElements
  Bopomofo
  BopomofoExtended
  BoxDrawing
  Brahmi
  BraillePatterns
  Buginese
  Buhid
  ByzantineMusicalSymbols
  Carian
  CaucasianAlbanian
  Chakma
  Cham
  Cherokee
  CherokeeSupplement
  ChessSymbols
  Chorasmian
  CJKUnifiedIdeographs
  CJKCompatibility
  CJKCompatibilityForms
  CJKCompatibilityIdeographs
  CJKCompatibilityIdeographsSupplement
  CJKUnifiedIdeographsExtensionA
  CJKUnifiedIdeographsExtensionB
  CJKUnifiedIdeographsExtensionC
  CJKUnifiedIdeographsExtensionD
  CJKUnifiedIdeographsExtensionE
  CJKUnifiedIdeographsExtensionF
  CJKUnifiedIdeographsExtensionG
  CJKRadicalsSupplement
  CJKStrokes
  HangulCompatibilityJamo
  ControlPictures
  Coptic
  CopticEpactNumbers
  CountingRodNumerals
  Cuneiform
  CurrencySymbols
  CypriotSyllabary
  Cyrillic
  CyrillicExtendedA
  CyrillicExtendedB
  CyrillicExtendedC
  CyrillicSupplement
  Deseret
  Devanagari
  DevanagariExtended
  CombiningDiacriticalMarks
  CombiningDiacriticalMarksExtended
  CombiningDiacriticalMarksSupplement
  Dingbats
  DivesAkuru
  Dogra
  DominoTiles
  Duployan
  EarlyDynasticCuneiform
  EgyptianHieroglyphFormatControls
  EgyptianHieroglyphs
  Elbasan
  Elymaic
  Emoticons
  EnclosedAlphanumerics
  EnclosedAlphanumericSupplement
  EnclosedIdeographicSupplement
  Ethiopic
  EthiopicExtended
  EthiopicExtendedA
  EthiopicSupplement
  GeometricShapes
  GeometricShapesExtended
  Georgian
  GeorgianExtended
  GeorgianSupplement
  Glagolitic
  GlagoliticSupplement
  Gothic
  Grantha
  GreekExtended
  Gujarati
  GunjalaGondi
  Gurmukhi
  CombiningHalfMarks
  HangulSyllables
  HanifiRohingya
  Hanunoo
  Hatran
  Hebrew
  HighPrivateUseSurrogates
  HighSurrogates
  Hiragana
  IdeographicDescriptionCharacters
  ImperialAramaic
  CommonIndicNumberForms
  IndicSiyaqNumbers
  InscriptionalPahlavi
  InscriptionalParthian
  IPAExtensions
  HangulJamo
  HangulJamoExtendedA
  HangulJamoExtendedB
  Javanese
  Kaithi
  KanaExtendedA
  KanaSupplement
  Kanbun
  KangxiRadicals
  Kannada
  Katakana
  KatakanaPhoneticExtensions
  KayahLi
  Kharoshthi
  KhitanSmallScript
  Khmer
  KhmerSymbols
  Khojki
  Khudawadi
  Lao
  Latin1Supplement
  LatinExtendedA
  LatinExtendedAdditional
  LatinExtendedB
  LatinExtendedC
  LatinExtendedD
  LatinExtendedE
  Lepcha
  LetterlikeSymbols
  Limbu
  LinearA
  LinearBIdeograms
  LinearBSyllabary
  Lisu
  LisuSupplement
  LowSurrogates
  Lycian
  Lydian
  Mahajani
  MahjongTiles
  Makasar
  Malayalam
  Mandaic
  Manichaean
  Marchen
  MasaramGondi
  MathematicalAlphanumericSymbols
  MathematicalOperators
  MayanNumerals
  Medefaidrin
  MeeteiMayek
  MeeteiMayekExtensions
  MendeKikakui
  MeroiticCursive
  MeroiticHieroglyphs
  Miao
  MiscellaneousMathematicalSymbolsA
  MiscellaneousMathematicalSymbolsB
  MiscellaneousSymbols
  MiscellaneousTechnical
  Modi
  SpacingModifierLetters
  ModifierToneLetters
  Mongolian
  MongolianSupplement
  Mro
  Multani
  MusicalSymbols
  Myanmar
  MyanmarExtendedA
  MyanmarExtendedB
  Nabataean
  Nandinagari
  NoBlock
  NewTaiLue
  Newa
  NKo
  NumberForms
  Nushu
  NyiakengPuachueHmong
  OpticalCharacterRecognition
  Ogham
  OlChiki
  OldHungarian
  OldItalic
  OldNorthArabian
  OldPermic
  OldPersian
  OldSogdian
  OldSouthArabian
  OldTurkic
  Oriya
  OrnamentalDingbats
  Osage
  Osmanya
  OttomanSiyaqNumbers
  PahawhHmong
  Palmyrene
  PauCinHau
  PhaistosDisc
  Phoenician
  PhoneticExtensions
  PhoneticExtensionsSupplement
  PlayingCards
  PsalterPahlavi
  PrivateUseArea
  GeneralPunctuation
  Rejang
  RumiNumeralSymbols
  Runic
  Samaritan
  Saurashtra
  Sharada
  Shavian
  ShorthandFormatControls
  Siddham
  Sinhala
  SinhalaArchaicNumbers
  SmallFormVariants
  SmallKanaExtension
  Sogdian
  SoraSompeng
  Soyombo
  Specials
  Sundanese
  SundaneseSupplement
  SupplementalArrowsA
  SupplementalArrowsB
  SupplementalArrowsC
  SupplementalMathematicalOperators
  SupplementaryPrivateUseAreaA
  SupplementaryPrivateUseAreaB
  SupplementalPunctuation
  SuttonSignWriting
  SylotiNagri
  Syriac
  SyriacSupplement
  Tagalog
  Tagbanwa
  Tags
  TaiLe
  TaiTham
  TaiViet
  TaiXuanJingSymbols
  Takri
  Tamil
  TamilSupplement
  Tangut
  TangutComponents
  TangutSupplement
  Telugu
  Thaana
  Thai
  Tibetan
  Tifinagh
  Tirhuta
  UnifiedCanadianAboriginalSyllabics
  UnifiedCanadianAboriginalSyllabicsExtended
  Ugaritic
  Vai
  VedicExtensions
  VerticalForms
  VariationSelectors
  VariationSelectorsSupplement
  Wancho
  WarangCiti
  Yezidi
  YiRadicals
  YiSyllables
  YijingHexagramSymbols
  ZanabazarSquare
  GreekandCoptic
  SuperscriptsandSubscripts
  CombiningDiacriticalMarksforSymbols
  MiscellaneousSymbolsandArrows
  CJKSymbolsandPunctuation
  EnclosedCJKLettersandMonths
  Phagspa
  HalfwidthandFullwidthForms
  CuneiformNumbersandPunctuation
  IdeographicSymbolsandPunctuation
  MiscellaneousSymbolsandPictographs
  TransportandMapSymbols
  SupplementalSymbolsandPictographs
  SymbolsandPictographsExtendedA
  SymbolsforLegacyComputing
}

pub(all) enum Boundary {
  None
  Word
  Line
  Mandatory
}

type BoundaryState

pub(all) enum BracketType {
  None
  Open(Char)
  Close(Char)
}

pub struct CacheKey {
  value : UInt64
}
pub fn CacheKey::new() -> Self
pub fn CacheKey::value(Self) -> UInt64

pub(all) enum Category {
  Other
  Control
  Format
  Unassigned
  PrivateUse
  Surrogate
  Letter
  CasedLetter
  LowercaseLetter
  ModifierLetter
  OtherLetter
  TitlecaseLetter
  UppercaseLetter
  Mark
  SpacingMark
  EnclosingMark
  NonspacingMark
  Number
  DecimalNumber
  LetterNumber
  OtherNumber
  Punctuation
  ConnectorPunctuation
  DashPunctuation
  ClosePunctuation
  FinalPunctuation
  InitialPunctuation
  OtherPunctuation
  OpenPunctuation
  Symbol
  CurrencySymbol
  ModifierSymbol
  MathSymbol
  OtherSymbol
  Separator
  LineSeparator
  ParagraphSeparator
  SpaceSeparator
}

type CharCluster
pub fn CharCluster::chars(Self) -> ArrayView[ClusterChar]
pub fn CharCluster::clear(Self) -> Unit
pub fn CharCluster::info(Self) -> ClusterInfo
pub fn CharCluster::is_empty(Self) -> Bool
pub fn CharCluster::map(Self, (Char) -> UInt16) -> Status
pub fn CharCluster::mapped_chars(Self) -> ArrayView[ClusterChar]
pub fn CharCluster::new() -> Self
pub fn CharCluster::range(Self) -> SourceRange
pub fn CharCluster::user_data(Self) -> UInt

type CharInfo
pub fn CharInfo::boundary(Self) -> Boundary
pub fn CharInfo::category(Self) -> Category
pub fn CharInfo::cluster_break(Self) -> ClusterBreak
pub fn CharInfo::cluster_class(Self) -> (ClusterBreak, Bool)
pub fn CharInfo::contributes_to_shaping(Self) -> Bool
pub fn CharInfo::default() -> Self
pub fn CharInfo::from_char(Char) -> Self
pub fn CharInfo::is_ignorable(Self) -> Bool
pub fn CharInfo::is_variation_selector(Self) -> Bool
pub fn CharInfo::joining_type(Self) -> JoiningType
pub fn CharInfo::myanmar_class(Self) -> (MyanmarClass, Bool)
pub fn CharInfo::new(Properties, Boundary) -> Self
pub fn CharInfo::properties(Self) -> Properties
pub fn CharInfo::use_class(Self) -> (UseClass, Bool, Bool)

type CharStream

pub struct Charmap {
  data : Bytes
  proxy : CharmapProxy
}
pub fn Charmap::enumerate(Self, (UInt, UInt16) -> Unit) -> Unit
pub fn Charmap::from_font(FontRef) -> Self
pub fn Charmap::map(Self, UInt) -> UInt16
pub fn Charmap::proxy(Self) -> CharmapProxy

pub struct CharmapProxy {
  offset : UInt
  format : UInt
  symbol : Bool
}
pub fn CharmapProxy::from_font(FontRef) -> Self
pub fn CharmapProxy::materialize(Self, FontRef) -> Charmap

pub(all) enum Cjk {
  None
  Traditional
  Simplified
  Japanese
  Korean
}

pub(all) enum ClusterBreak {
  CN
  CR
  EX
  L
  LF
  LV
  LVT
  PP
  RI
  SM
  T
  V
  XX
  ZWJ
}

type ClusterChar
pub fn ClusterChar::ch(Self) -> Char
pub fn ClusterChar::contributes_to_shaping(Self) -> Bool
pub fn ClusterChar::data(Self) -> UInt
pub fn ClusterChar::glyph_id(Self) -> UInt16
pub fn ClusterChar::is_ignorable(Self) -> Bool
pub fn ClusterChar::joining_type(Self) -> JoiningType
pub fn ClusterChar::new(Char, UInt, ShapeClass, JoiningType, Bool, Bool, UInt16, UInt) -> Self
pub fn ClusterChar::offset(Self) -> UInt
pub fn ClusterChar::shape_class(Self) -> ShapeClass

type ClusterInfo
pub fn ClusterInfo::boundary(Self) -> Boundary
pub fn ClusterInfo::emoji(Self) -> Emoji
pub fn ClusterInfo::is_boundary(Self) -> Bool
pub fn ClusterInfo::is_broken(Self) -> Bool
pub fn ClusterInfo::is_emoji(Self) -> Bool
pub fn ClusterInfo::is_whitespace(Self) -> Bool
pub fn ClusterInfo::whitespace(Self) -> Whitespace

pub struct ColorPalette {
  font : FontRef
  b : @internal.BeBytes
  version : UInt16
  index : UInt16
  num_entries : UInt16
  offset : Int
}
pub fn ColorPalette::get(Self, UInt16) -> (Byte, Byte, Byte, Byte)
pub fn ColorPalette::index(Self) -> UInt16
pub fn ColorPalette::is_empty(Self) -> Bool
pub fn ColorPalette::len(Self) -> UInt16
pub fn ColorPalette::name(Self, String?) -> LocalizedString?
pub fn ColorPalette::name_id(Self) -> StringId?
pub fn ColorPalette::usability(Self) -> Usability?

pub struct ColorPalettes {
  font : FontRef
  b : @internal.BeBytes
  len : Int
}
pub fn ColorPalettes::from_font(FontRef) -> Self
pub fn ColorPalettes::iter(Self) -> Iter[ColorPalette]
pub fn ColorPalettes::len(Self) -> Int

pub(all) enum CombiningClass {
  NotReordered
  Overlay
  HanReading
  Nukta
  KanaVoicing
  Virama
  Ccc10
  Ccc11
  Ccc12
  Ccc13
  Ccc14
  Ccc15
  Ccc16
  Ccc17
  Ccc18
  Ccc19
  Ccc20
  Ccc21
  Ccc22
  Ccc23
  Ccc24
  Ccc25
  Ccc26
  Ccc27
  Ccc28
  Ccc29
  Ccc30
  Ccc31
  Ccc32
  Ccc33
  Ccc34
  Ccc35
  Ccc36
  Ccc84
  Ccc91
  Ccc103
  Ccc107
  Ccc118
  Ccc122
  Ccc129
  Ccc130
  Ccc132
  Ccc133
  AttachedBelowLeft
  AttachedBelow
  AttachedAbove
  AttachedAboveRight
  BelowLeft
  Below
  BelowRight
  Left
  Right
  AboveLeft
  Above
  AboveRight
  DoubleBelow
  DoubleAbove
  IotaSubscript
}

pub(all) enum Emoji {
  None
  Default
  Text
  Color
}

pub(all) enum Encoding {
  Unicode
  MacRoman
  Other(UInt16, UInt16)
}
pub fn Encoding::is_decodable(Self) -> Bool

type Entry[T]

type Feature
pub fn Feature::action(Self) -> Action
pub fn Feature::name(Self) -> String?
pub fn Feature::tag(Self) -> UInt

type Features
pub fn Features::from_font(FontRef) -> Self
pub fn Features::iter(Self) -> Iter[Feature]

pub struct FontCache[T] {
  entries : Array[Entry[T]]
  max_entries : Int
  mut epoch : UInt64
}
pub fn[T] FontCache::get(Self[T], FontRef, (UInt64, UInt64)?, (FontRef) -> T) -> ((UInt64, UInt64), Ref[T])
pub fn[T] FontCache::new(Int) -> Self[T]

pub struct FontDataRef {
  data : Bytes
  len : Int
}
pub fn FontDataRef::data(Self) -> Bytes
pub fn FontDataRef::fonts(Self) -> Iter[FontRef]
pub fn FontDataRef::get(Self, Int) -> FontRef?
pub fn FontDataRef::is_collection(Self) -> Bool
pub fn FontDataRef::is_empty(Self) -> Bool
pub fn FontDataRef::len(Self) -> Int
pub fn FontDataRef::new(Bytes) -> Self?

pub struct FontRef {
  data : Bytes
  offset : Int
  key : CacheKey
}
pub fn FontRef::alpha_strikes(Self) -> BitmapStrikes
pub fn FontRef::attributes(Self) -> Attributes
pub fn FontRef::color_palettes(Self) -> ColorPalettes
pub fn FontRef::color_strikes(Self) -> BitmapStrikes
pub fn FontRef::data(Self) -> Bytes
pub fn FontRef::features(Self) -> Features
pub fn FontRef::from_index(Bytes, Int) -> Self?
pub fn FontRef::from_offset(Bytes, Int) -> Self?
pub fn FontRef::glyph_metrics(Self, ArrayView[Int]) -> GlyphMetrics
pub fn FontRef::head(Self) -> @internal.Head?
pub fn FontRef::hhea(Self) -> @internal.Hhea?
pub fn FontRef::instances(Self) -> Iter[Instance]
pub fn FontRef::key(Self) -> CacheKey
pub fn FontRef::localized_strings(Self) -> LocalizedStrings
pub fn FontRef::maxp(Self) -> @internal.Maxp?
pub fn FontRef::metrics(Self, ArrayView[Int]) -> Metrics
pub fn FontRef::offset(Self) -> Int
pub fn FontRef::os2(Self) -> @internal.Os2?
pub fn FontRef::post(Self) -> @internal.Post?
pub fn FontRef::table_data(Self, UInt) -> BytesView?
pub fn FontRef::table_offset(Self, UInt) -> UInt
pub fn FontRef::variations(Self) -> Iter[Variation]
pub fn FontRef::vhea(Self) -> @internal.Vhea?
pub fn FontRef::writing_systems(Self) -> WritingSystems
pub impl @internal.RawFont for FontRef

type GlyphMetrics
pub fn GlyphMetrics::advance_height(Self, UInt16) -> Double
pub fn GlyphMetrics::advance_width(Self, UInt16) -> Double
pub fn GlyphMetrics::glyph_count(Self) -> UInt16
pub fn GlyphMetrics::has_variations(Self) -> Bool
pub fn GlyphMetrics::has_vertical_metrics(Self) -> Bool
pub fn GlyphMetrics::linear_scale(Self, Double) -> Self
pub fn GlyphMetrics::lsb(Self, UInt16) -> Double
pub fn GlyphMetrics::scale(Self, Double) -> Self
pub fn GlyphMetrics::tsb(Self, UInt16) -> Double
pub fn GlyphMetrics::units_per_em(Self) -> UInt16
pub fn GlyphMetrics::vertical_origin(Self, UInt16) -> Double

type Instance
pub fn Instance::index(Self) -> Int
pub fn Instance::name(Self, String?) -> LocalizedString?
pub fn Instance::name_id(Self) -> StringId
pub fn Instance::normalized_coords(Self) -> ArrayView[Int]
pub fn Instance::postscript_name(Self, String?) -> LocalizedString?
pub fn Instance::postscript_name_id(Self) -> StringId?
pub fn Instance::values(Self) -> ArrayView[Double]

pub(all) enum JoiningType {
  U
  L
  R
  D
  Alaph
  DalathRish
  T
}

pub struct Language {
  language : Array[Byte]
  script : Array[Byte]
  region : Array[Byte]
  lang_len : Int
  script_len : Int
  region_len : Int
  cjk : Cjk
  name_index : Int
  tag : UInt?
}
pub fn Language::cjk(Self) -> Cjk
pub fn Language::from_opentype(UInt) -> Self?
pub fn Language::language(Self) -> String
pub fn Language::name(Self) -> String?
pub fn Language::parse(String) -> Self?
pub fn Language::region(Self) -> String?
pub fn Language::script(Self) -> String?
pub fn Language::to_opentype(Self) -> UInt?
pub fn Language::to_string(Self) -> String
pub impl Show for Language

pub(all) enum LineBreak {
  AI
  AL
  B2
  BA
  BB
  BK
  CB
  CJ
  CL
  CM
  CP
  CR
  EB
  EM
  EX
  GL
  H2
  H3
  HL
  HY
  ID
  IN
  IS
  JL
  JT
  JV
  LF
  NL
  NS
  NU
  OP
  PO
  PR
  QU
  RI
  SA
  SG
  SP
  SY
  WJ
  XX
  ZW
  ZWJ
}

pub struct LocalizedString {
  b : @internal.BeBytes
  storage : Int
  offset : Int
}
pub fn LocalizedString::chars(Self) -> Iter[Char]
pub fn LocalizedString::id(Self) -> StringId
pub fn LocalizedString::is_decodable(Self) -> Bool
pub fn LocalizedString::is_unicode(Self) -> Bool
pub fn LocalizedString::language(Self) -> String
pub fn LocalizedString::to_string(Self) -> String

pub struct LocalizedStrings {
  b : @internal.BeBytes
  len : Int
  storage : Int
}
pub fn LocalizedStrings::find_by_id(Self, StringId, String?) -> LocalizedString?
pub fn LocalizedStrings::iter(Self) -> Iter[LocalizedString]
pub fn LocalizedStrings::len(Self) -> Int

pub struct Metrics {
  units_per_em : UInt16
  glyph_count : UInt16
  is_monospace : Bool
  has_vertical_metrics : Bool
  ascent : Double
  descent : Double
  leading : Double
  vertical_ascent : Double
  vertical_descent : Double
  vertical_leading : Double
  cap_height : Double
  x_height : Double
  average_width : Double
  max_width : Double
  underline_offset : Double
  strikeout_offset : Double
  stroke_size : Double
}
pub fn Metrics::linear_scale(Self, Double) -> Self
pub fn Metrics::scale(Self, Double) -> Self

type MetricsProxy
pub fn MetricsProxy::from_font(FontRef) -> Self
pub fn MetricsProxy::glyph_count(Self) -> UInt16
pub fn MetricsProxy::materialize_glyph_metrics(Self, FontRef, ArrayView[Int]) -> GlyphMetrics
pub fn MetricsProxy::materialize_metrics(Self, FontRef, ArrayView[Int]) -> Metrics
pub fn MetricsProxy::units_per_em(Self) -> UInt16

pub(all) enum MyanmarClass {
  A
  As
  C
  D
  D0
  DB
  GB
  H
  IV
  J
  K
  MH
  MR
  MW
  MY
  O
  P
  PT
  R
  S
  V
  VAbv
  VBlw
  VPre
  VPst
  VS
  WJ
}

pub struct ObliqueAngle {
  value : UInt16
}
pub fn ObliqueAngle::from_degrees(Double) -> Self
pub fn ObliqueAngle::from_gradians(Double) -> Self
pub fn ObliqueAngle::from_radians(Double) -> Self
pub fn ObliqueAngle::from_turns(Double) -> Self
pub fn ObliqueAngle::to_degrees(Self) -> Double

type Parser
pub fn Parser::new(Script, Iter[Token]) -> Self
pub fn Parser::next(Self, CharCluster) -> Bool

pub struct Properties {
  bits : UInt
}
pub fn Properties::bidi_class(Self) -> BidiClass
pub fn Properties::block(Self) -> Block
pub fn Properties::boundary(Self) -> UInt
pub fn Properties::category(Self) -> Category
pub fn Properties::cluster_break(Self) -> ClusterBreak
pub fn Properties::cluster_class(Self) -> (ClusterBreak, Bool)
pub fn Properties::combining_class(Self) -> UInt
pub fn Properties::contributes_to_shaping(Self) -> Bool
pub fn Properties::is_close_bracket(Self) -> Bool
pub fn Properties::is_emoji(Self) -> Bool
pub fn Properties::is_extended_pictographic(Self) -> Bool
pub fn Properties::is_ignorable(Self) -> Bool
pub fn Properties::is_open_bracket(Self) -> Bool
pub fn Properties::is_variation_selector(Self) -> Bool
pub fn Properties::joining_type(Self) -> JoiningType
pub fn Properties::line_break(Self) -> LineBreak
pub fn Properties::myanmar_class(Self) -> (MyanmarClass, Bool)
pub fn Properties::script(Self) -> Script
pub fn Properties::use_class(Self) -> (UseClass, Bool, Bool)
pub fn Properties::with_boundary(Self, UInt) -> Self
pub fn Properties::word_break(Self) -> WordBreak

pub(all) enum Script {
  Adlam
  CaucasianAlbanian
  Ahom
  Arabic
  ImperialAramaic
  Armenian
  Avestan
  Balinese
  Bamum
  BassaVah
  Batak
  Bengali
  Bhaiksuki
  Bopomofo
  Brahmi
  Braille
  Buginese
  Buhid
  Chakma
  CanadianAboriginal
  Carian
  Cham
  Cherokee
  Chorasmian
  Coptic
  Cypriot
  Cyrillic
  Devanagari
  DivesAkuru
  Dogra
  Deseret
  Duployan
  EgyptianHieroglyphs
  Elbasan
  Elymaic
  Ethiopic
  Georgian
  Glagolitic
  GunjalaGondi
  MasaramGondi
  Gothic
  Grantha
  Greek
  Gujarati
  Gurmukhi
  Hangul
  Han
  Hanunoo
  Hatran
  Hebrew
  Hiragana
  AnatolianHieroglyphs
  PahawhHmong
  NyiakengPuachueHmong
  OldHungarian
  OldItalic
  Javanese
  KayahLi
  Katakana
  Kharoshthi
  Khmer
  Khojki
  KhitanSmallScript
  Kannada
  Kaithi
  TaiTham
  Lao
  Latin
  Lepcha
  Limbu
  LinearA
  LinearB
  Lisu
  Lycian
  Lydian
  Mahajani
  Makasar
  Mandaic
  Manichaean
  Marchen
  Medefaidrin
  MendeKikakui
  MeroiticCursive
  MeroiticHieroglyphs
  Malayalam
  Modi
  Mongolian
  Mro
  MeeteiMayek
  Multani
  Myanmar
  Nandinagari
  OldNorthArabian
  Nabataean
  Newa
  Nko
  Nushu
  Ogham
  OlChiki
  OldTurkic
  Oriya
  Osage
  Osmanya
  Palmyrene
  PauCinHau
  OldPermic
  PhagsPa
  InscriptionalPahlavi
  PsalterPahlavi
  Phoenician
  Miao
  InscriptionalParthian
  Rejang
  HanifiRohingya
  Runic
  Samaritan
  OldSouthArabian
  Saurashtra
  SignWriting
  Shavian
  Sharada
  Siddham
  Khudawadi
  Sinhala
  Sogdian
  OldSogdian
  SoraSompeng
  Soyombo
  Sundanese
  SylotiNagri
  Syriac
  Tagbanwa
  Takri
  TaiLe
  NewTaiLue
  Tamil
  Tangut
  TaiViet
  Telugu
  Tifinagh
  Tagalog
  Thaana
  Thai
  Tibetan
  Tirhuta
  Ugaritic
  Vai
  WarangCiti
  Wancho
  OldPersian
  Cuneiform
  Yezidi
  Yi
  ZanabazarSquare
  Inherited
  Common
  Unknown
}
pub fn Script::from_opentype(UInt) -> Self?
pub fn Script::is_complex(Self) -> Bool
pub fn Script::is_joined(Self) -> Bool
pub fn Script::name(Self) -> String
pub fn Script::to_opentype(Self) -> UInt

pub struct SeenFeatures {
  bits : Array[UInt]
}
pub fn SeenFeatures::mark(Self, Int) -> Bool
pub fn SeenFeatures::new() -> Self

pub struct Setting[T] {
  tag : UInt
  value : T
}
pub fn[T] Setting::new(UInt, T) -> Self[T]
pub fn Setting::parse_feature(String) -> Self[UInt16]?
pub fn Setting::parse_feature_list(String) -> Iter[Self[UInt16]]
pub fn Setting::parse_variation(String) -> Self[Double]?
pub fn Setting::parse_variation_list(String) -> Iter[Self[Double]]

pub(all) enum ShapeClass {
  Reph
  Pref
  Kinzi
  Base
  Mark
  Halant
  MedialRa
  VMPre
  VPre
  VBlw
  Anusvara
  Zwj
  Zwnj
  Control
  Vs
  Other
}

type SourceRange
pub fn SourceRange::end(Self) -> UInt
pub fn SourceRange::start(Self) -> UInt

pub(all) enum Status {
  Discard
  Keep
  Complete
}

pub struct Stretch {
  value : UInt16
}
pub fn Stretch::condensed() -> Self
pub fn Stretch::expanded() -> Self
pub fn Stretch::extra_condensed() -> Self
pub fn Stretch::extra_expanded() -> Self
pub fn Stretch::from_percentage(Double) -> Self
pub fn Stretch::is_condensed(Self) -> Bool
pub fn Stretch::is_expanded(Self) -> Bool
pub fn Stretch::is_normal(Self) -> Bool
pub fn Stretch::normal() -> Self
pub fn Stretch::parse(String) -> Self?
pub fn Stretch::raw(Self) -> UInt16
pub fn Stretch::semi_condensed() -> Self
pub fn Stretch::semi_expanded() -> Self
pub fn Stretch::to_percentage(Self) -> Double
pub fn Stretch::to_string(Self) -> String
pub fn Stretch::ultra_condensed() -> Self
pub fn Stretch::ultra_expanded() -> Self
pub impl Compare for Stretch
pub impl Eq for Stretch
pub impl Show for Stretch

pub(all) enum StringId {
  Copyright
  Family
  SubFamily
  UniqueId
  Full
  Version
  PostScript
  Trademark
  Manufacturer
  Designer
  Description
  VendorUrl
  DesignerUrl
  License
  LicenseUrl
  TypographicFamily
  TypographicSubFamily
  CompatibleFull
  SampleText
  PostScriptCid
  WwsFamily
  WwsSubFamily
  LightBackgroundPalette
  DarkBackgroundPalette
  VariationsPostScriptNamePrefix
  Other(UInt16)
}
pub fn StringId::from_raw(UInt16) -> Self
pub fn StringId::to_raw(Self) -> UInt16

pub(all) enum Style {
  Normal
  Italic
  Oblique(ObliqueAngle)
}
pub fn Style::from_degrees(Double) -> Self
pub fn Style::parse(String) -> Self?
pub fn Style::to_degrees(Self) -> Double
pub fn Style::to_string(Self) -> String
pub impl Eq for Style
pub impl Show for Style

pub struct Synthesis {
  vars : Array[Setting[Double]]
  embolden : Bool
  skew : Int
}
pub fn Synthesis::any(Self) -> Bool
pub fn Synthesis::embolden(Self) -> Bool
pub fn Synthesis::skew(Self) -> Double?
pub fn Synthesis::variations(Self) -> ArrayView[Setting[Double]]
pub impl Eq for Synthesis

type Token
pub fn Token::ch(Self) -> Char
pub fn Token::data(Self) -> UInt
pub fn Token::default() -> Self
pub fn Token::info(Self) -> CharInfo
pub fn Token::len(Self) -> UInt
pub fn Token::new(Char, UInt, UInt, CharInfo, UInt) -> Self
pub fn Token::offset(Self) -> UInt

pub(all) enum Usability {
  Light
  Dark
  Both
}

pub(all) enum UseClass {
  B
  CGJ
  CMAbv
  CMBlw
  CS
  FAbv
  FBlw
  FPst
  FM
  GB
  H
  HN
  IND
  MAbv
  MBlw
  MPre
  MPst
  N
  O
  R
  Rsv
  S
  SMAbv
  SMBlw
  SUB
  VAbv
  VBlw
  VPre
  VPst
  VMAbv
  VMBlw
  VMPre
  VMPst
  VS
  WJ
  ZWJ
  ZWNJ
}

type Variation
pub fn Variation::default_value(Self) -> Double
pub fn Variation::index(Self) -> Int
pub fn Variation::is_hidden(Self) -> Bool
pub fn Variation::max_value(Self) -> Double
pub fn Variation::min_value(Self) -> Double
pub fn Variation::name(Self, String?) -> LocalizedString?
pub fn Variation::name_id(Self) -> StringId
pub fn Variation::normalize(Self, Double) -> Int
pub fn Variation::tag(Self) -> UInt

pub struct Weight {
  value : UInt16
}
pub fn Weight::black() -> Self
pub fn Weight::bold() -> Self
pub fn Weight::extra_bold() -> Self
pub fn Weight::extra_light() -> Self
pub fn Weight::light() -> Self
pub fn Weight::medium() -> Self
pub fn Weight::normal() -> Self
pub fn Weight::parse(String) -> Self?
pub fn Weight::semi_bold() -> Self
pub fn Weight::thin() -> Self
pub fn Weight::to_string(Self) -> String
pub impl Compare for Weight
pub impl Eq for Weight
pub impl Show for Weight

pub(all) enum Whitespace {
  None
  Space
  NoBreakSpace
  Tab
  Newline
  Other
}
pub fn Whitespace::is_space_or_nbsp(Self) -> Bool

pub(all) enum WordBreak {
  CR
  DQ
  EX
  Extend
  FO
  HL
  KA
  LE
  LF
  MB
  ML
  MN
  NL
  NU
  RI
  SQ
  WSegSpace
  XX
  ZWJ
}

pub(all) enum WordBreakStrength {
  Normal
  BreakAll
  KeepAll
}

type WritingSystem
pub fn WritingSystem::features(Self) -> Features
pub fn WritingSystem::language(Self) -> Language?
pub fn WritingSystem::language_tag(Self) -> UInt
pub fn WritingSystem::script(Self) -> Script?
pub fn WritingSystem::script_tag(Self) -> UInt

type WritingSystems
pub fn WritingSystems::from_font(FontRef) -> Self
pub fn WritingSystems::iter(Self) -> Iter[WritingSystem]

// Type aliases
pub type Decompose = Iter[Char]

pub type FeatureSetting = Setting[UInt16]

pub type GlyphId = UInt16

pub type NormalizedCoord = Int

pub type Tag = UInt

pub type UserData = UInt

pub type VariationSetting = Setting[Double]

// Traits
pub(open) trait Codepoint {
  properties(Self) -> Properties
  opening_bracket(Self) -> Char?
  closing_bracket(Self) -> Char?
  mirror(Self) -> Char?
  bracket_type(Self) -> BracketType
  decompose(Self) -> Iter[Char]
  decompose_compatible(Self) -> Iter[Char]
}
pub impl Codepoint for Char

