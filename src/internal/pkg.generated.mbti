// Generated using `moon info`, DON'T EDIT IT
package "Milky2018/moon_swash/internal"

// Values
pub const ANKR : UInt = 0x616E6B72

pub const AVAR : UInt = 0x61766172

pub const CPHT : UInt = 0x63706874

pub const CVAR : UInt = 0x63766172

pub const CVT_ : UInt = 0x63767420

pub const DFLT : UInt = 0x44464C54

pub const FPGM : UInt = 0x6670676D

pub const FVAR : UInt = 0x66766172

pub const GLYF : UInt = 0x676C7966

pub const GPOS : UInt = 0x47504F53

pub const GSUB : UInt = 0x47535542

pub const GVAR : UInt = 0x67766172

pub const HASC : UInt = 0x68617363

pub const HDSC : UInt = 0x68647363

pub const HEAD : UInt = 0x68656164

pub const HEAD_MAGIC : UInt = 0x5F0F3CF5

pub const HHEA : UInt = 0x68686561

pub const HLGP : UInt = 0x686C6770

pub const HMTX : UInt = 0x686D7478

pub const HVAR : UInt = 0x48564152

pub const KERN : UInt = 0x6B65726E

pub const KERX : UInt = 0x6B657278

pub const LOCA : UInt = 0x6C6F6361

pub const LTAG : UInt = 0x6C746167

pub const MAXP : UInt = 0x6D617870

pub const MORX : UInt = 0x6D6F7278

pub const MVAR : UInt = 0x4D564152

pub const OS_2 : UInt = 0x4F532F32

pub const POST : UInt = 0x706F7374

pub const PREP : UInt = 0x70726570

pub const STRO : UInt = 0x7374726F

pub const UNDO : UInt = 0x756E646F

pub const UNDS : UInt = 0x756E6473

pub const VASC : UInt = 0x76617363

pub const VDSC : UInt = 0x76647363

pub const VHEA : UInt = 0x76686561

pub const VLGP : UInt = 0x766C6770

pub const VMTX : UInt = 0x766D7478

pub const VORG : UInt = 0x564F5247

pub const VVAR : UInt = 0x56564152

pub const XHGT : UInt = 0x78686774

pub fn aat_lookup_u16(BeBytes, Int, UInt16) -> UInt16?

pub fn advance(Bytes, UInt, UInt, UInt) -> UInt

pub fn advance_delta(Bytes, UInt, UInt, ArrayView[Int]) -> Double

pub fn ceil(Int) -> Int

pub fn classdef(Bytes, UInt, UInt16) -> UInt16

pub fn count(Bytes) -> Int

pub fn coverage(Bytes, UInt, UInt16) -> UInt16?

pub fn div(Int, Int) -> Int

pub fn enumerate(Bytes, UInt, (UInt, UInt) -> Unit) -> Unit

pub fn feature_at(Bytes, UInt, UInt16) -> (UInt, UInt)?

pub fn feature_count(Bytes, UInt) -> UInt16

pub fn floor(Int) -> Int

pub fn get(Bytes, UInt, UInt, UInt, UInt) -> BytesView?

pub fn is_collection(Bytes) -> Bool

pub fn is_font(Bytes, Int) -> Bool

pub fn item_delta(Bytes, UInt, UInt, UInt, ArrayView[Int]) -> Fixed?

pub fn kern_subtables(Bytes, UInt) -> KernSubtables

pub fn kerx_anchor_points(BytesView, UInt16) -> KerxAnchorPoints?

pub fn kerx_subtables(Bytes, UInt, UInt) -> KerxSubtables

pub fn language_feature_at(Bytes, UInt, UInt16) -> UInt16?

pub fn language_feature_count(Bytes, UInt) -> UInt16

pub fn lookup_data(Bytes, Byte, UInt, UInt16, Byte, Gdef?) -> LookupData?

pub fn map(Bytes, UInt, UInt, UInt) -> UInt?

pub fn morx_chains(Bytes, UInt) -> MorxChains

pub fn morx_feature_from_tag(UInt) -> (UInt16, (UInt16, UInt16))?

pub fn morx_language_index(Bytes, UInt, String) -> UInt?

pub fn mul(Int, Int) -> Int

pub fn muldiv(Int, Int, Int) -> Int

pub fn offset(Bytes, Int) -> Int?

pub fn origin(Bytes, UInt, UInt) -> Int?

pub fn raw_tag(Bytes) -> UInt?

pub fn round(Int) -> Int

pub fn sb(Bytes, UInt, UInt, UInt) -> Int

pub fn sb_delta(Bytes, UInt, UInt, ArrayView[Int]) -> Double

pub fn script_at(Bytes, UInt, UInt16) -> (UInt, UInt)?

pub fn script_by_tag(Bytes, UInt, UInt) -> UInt?

pub fn script_count(Bytes, UInt) -> UInt16

pub fn script_default_language(Bytes, UInt) -> UInt?

pub fn script_language_at(Bytes, UInt, UInt16) -> (UInt, UInt)?

pub fn script_language_by_tag(Bytes, UInt, UInt?) -> (UInt, Bool)?

pub fn script_language_count(Bytes, UInt) -> UInt16

pub fn[T : RawFont] subtable(T) -> (UInt, UInt, Bool)?

pub fn subtable_data(Bytes, UInt, LookupKind, UInt16) -> SubtableData?

pub fn[T : RawFont] table_data(T, UInt) -> BytesView?

pub fn[T : RawFont] table_offset(T, UInt) -> UInt

pub fn[T : RawFont] table_range(T, UInt) -> (UInt, UInt)?

pub fn validate_coverage(Bytes, UInt) -> Bool

pub fn ymax(Bytes, UInt, UInt, UInt, UInt) -> Int?

// Errors

// Types and methods
pub(all) struct AatEntry[T] {
  mut new_state : UInt16
  flags : UInt16
  data : T
}

pub struct BeBytes {
  data : BytesView
}
pub fn BeBytes::check_range(Self, Int, Int) -> Bool
pub fn BeBytes::data(Self) -> BytesView
pub fn BeBytes::ensure_range(Self, Int, Int) -> Bool
pub fn BeBytes::from_view(BytesView) -> Self
pub fn BeBytes::len(Self) -> Int
pub fn BeBytes::new(Bytes) -> Self
pub fn BeBytes::read_i16(Self, Int) -> Int?
pub fn BeBytes::read_i32(Self, Int) -> Int?
pub fn BeBytes::read_u16(Self, Int) -> UInt?
pub fn BeBytes::read_u24(Self, Int) -> UInt?
pub fn BeBytes::read_u32(Self, Int) -> UInt?
pub fn BeBytes::read_u64(Self, Int) -> UInt64?
pub fn BeBytes::read_u8(Self, Int) -> Byte?
pub fn BeBytes::with_offset(Bytes, Int) -> Self?

pub(all) struct ExtendedStateTable {
  b : BeBytes
  classes : Int
  class_table : Int
  state_array : Int
  entry_table : Int
}
pub fn ExtendedStateTable::class(Self, UInt16) -> UInt16
pub fn[T] ExtendedStateTable::entry(Self, UInt16, UInt16, Int, (BeBytes, Int) -> T?) -> AatEntry[T]?
pub fn ExtendedStateTable::new(BytesView) -> Self?

pub struct FeatureSubsts {
  offset : UInt
}
pub fn FeatureSubsts::apply(Self, Bytes, UInt16) -> UInt?
pub fn FeatureSubsts::new(Bytes, UInt, ArrayView[Int]) -> Self?

pub struct Fixed {
  value : Int
}
pub fn Fixed::abs(Self) -> Self
pub fn Fixed::epsilon() -> Self
pub fn Fixed::floor(Self) -> Self
pub fn Fixed::fract(Self) -> Self
pub fn Fixed::from_f2dot14(Int) -> Self
pub fn Fixed::from_f32(Double) -> Self
pub fn Fixed::from_i32(Int) -> Self
pub fn Fixed::from_raw(Int) -> Self
pub fn Fixed::max(Self, Self) -> Self
pub fn Fixed::max_value() -> Self
pub fn Fixed::min(Self, Self) -> Self
pub fn Fixed::min_value() -> Self
pub fn Fixed::one() -> Self
pub fn Fixed::raw(Self) -> Int
pub fn Fixed::round(Self) -> Self
pub fn Fixed::to_f2dot14(Self) -> Int
pub fn Fixed::to_f32(Self) -> Double
pub fn Fixed::to_i32(Self) -> Int
pub fn Fixed::zero() -> Self
pub impl Add for Fixed
pub impl Div for Fixed
pub impl Mul for Fixed
pub impl Neg for Fixed
pub impl Sub for Fixed

pub struct Gdef {
  data : Bytes
  base : Int
  classes : UInt16
  mark_classes : UInt16
  mark_sets : UInt16
  var_store : UInt
}
pub fn Gdef::class(Self, UInt16) -> UInt16
pub fn Gdef::delta(Self, UInt16, UInt16, ArrayView[Int]) -> Double
pub fn Gdef::empty() -> Self
pub fn Gdef::from_offset(Bytes, UInt) -> Self?
pub fn Gdef::has_classes(Self) -> Bool
pub fn Gdef::has_mark_classes(Self) -> Bool
pub fn Gdef::has_var_store(Self) -> Bool
pub fn Gdef::mark_class(Self, UInt16) -> UInt16
pub fn Gdef::mark_set_coverage(Self, UInt, UInt16) -> UInt16?
pub fn Gdef::mark_set_offset(Self, UInt16) -> UInt?
pub fn Gdef::new(Bytes, Int) -> Self?
pub fn Gdef::ok(Self) -> Bool

pub struct Head {
  data : BytesView
}
pub fn Head::bounds(Self) -> ((Int, Int), (Int, Int))
pub fn Head::checksum_adjustment(Self) -> UInt
pub fn Head::created(Self) -> UInt64
pub fn Head::direction_hint(Self) -> UInt
pub fn Head::flags(Self) -> UInt
pub fn[T : RawFont] Head::from_font(T) -> Self?
pub fn Head::glyph_data_format(Self) -> Int
pub fn Head::index_to_location_format(Self) -> UInt
pub fn Head::lowest_recommended_ppem(Self) -> UInt
pub fn Head::mac_style(Self) -> UInt
pub fn Head::magic(Self) -> UInt
pub fn Head::major_version(Self) -> UInt
pub fn Head::minor_version(Self) -> UInt
pub fn Head::modified(Self) -> UInt64
pub fn Head::new(BytesView) -> Self
pub fn Head::revision(Self) -> UInt
pub fn Head::units_per_em(Self) -> UInt

pub struct Hhea {
  data : BytesView
}
pub fn Hhea::ascender(Self) -> Int
pub fn Hhea::descender(Self) -> Int
pub fn[T : RawFont] Hhea::from_font(T) -> Self?
pub fn Hhea::line_gap(Self) -> Int
pub fn Hhea::max_advance(Self) -> UInt
pub fn Hhea::new(BytesView) -> Self
pub fn Hhea::num_long_metrics(Self) -> UInt

pub struct KernFormat0 {
  b : BeBytes
  base : Int
  count : Int
}
pub fn KernFormat0::get(Self, UInt16, UInt16) -> Int?

pub struct KernFormat1 {
  b : BeBytes
  state_table : StateTable
  cross_stream : Bool
}
pub fn KernFormat1::next(Self, KernFormat1State, Int, UInt16, (Int, Int) -> Unit?) -> Int?

pub struct KernFormat1State {
  mut state : UInt16
  stack : Array[Int]
  mut pos : Int
  mut cycles : Int
}
pub fn KernFormat1State::new() -> Self

pub struct KernSubtable {
  b : BeBytes
  offset : Int
  size : UInt
  is_horizontal : Bool
  cross_stream : Bool
  format : Byte
  is_aat : Bool
}
pub fn KernSubtable::cross_stream(Self) -> Bool
pub fn KernSubtable::is_horizontal(Self) -> Bool
pub fn KernSubtable::kind(Self) -> KernSubtableKind?

pub(all) enum KernSubtableKind {
  Format0(KernFormat0)
  Format1(KernFormat1)
}

pub struct KernSubtables {
  b : BeBytes
  offset : Int
  len : UInt
  cur : UInt
  is_aat : Bool
}
pub fn KernSubtables::iter(Self) -> Iter[KernSubtable]

pub struct KerxAnchorPoints {
  b : BeBytes
  offset : Int
  len : UInt
}
pub fn KerxAnchorPoints::get(Self, UInt16) -> (Int, Int)?

pub struct KerxContextualState {
  mut state : UInt16
  stack : Array[Int]
  mut pos : Int
  mut cycles : Int
}
pub fn KerxContextualState::new() -> Self

pub struct KerxFormat0 {
  b : BeBytes
  count : Int
}
pub fn KerxFormat0::get(Self, UInt16, UInt16) -> Int?

pub struct KerxFormat1 {
  b : BeBytes
  state_table : ExtendedStateTable
  value : Int
  tuple_count : UInt
  tuple_size : Int
}
pub fn KerxFormat1::next(Self, KerxContextualState, Int, UInt16, (Int, Int) -> Unit?) -> Int?

pub struct KerxFormat2 {
  b : BeBytes
  l_table : Int
  r_table : Int
  array : Int
}
pub fn KerxFormat2::get(Self, UInt16, UInt16) -> Int?

pub struct KerxFormat4 {
  b : BeBytes
  state_table : ExtendedStateTable
  action_type : UInt
  control_table : Int
  ankr : BytesView
}
pub fn KerxFormat4::next(Self, KerxFormat4State, Int, UInt16, (Int, Int, Double, Double) -> Unit?) -> Int?

pub struct KerxFormat4State {
  mut state : UInt16
  mut mark : Int
  mut mark_id : UInt16
  mut cycles : Int
}
pub fn KerxFormat4State::new() -> Self

pub struct KerxSubtable {
  b : BeBytes
  version : UInt16
  size : UInt
  coverage : UInt
  tuple_count : UInt
  ankr : BytesView
}
pub fn KerxSubtable::is_cross_stream(Self) -> Bool
pub fn KerxSubtable::is_vertical(Self) -> Bool
pub fn KerxSubtable::kind(Self) -> KerxSubtableKind?
pub fn KerxSubtable::should_reverse(Self, Bool) -> Bool

pub(all) enum KerxSubtableKind {
  Format0(KerxFormat0)
  Format1(KerxFormat1)
  Format2(KerxFormat2)
  Format4(KerxFormat4)
}

pub struct KerxSubtables {
  b : BeBytes
  version : UInt16
  offset : Int
  len : UInt
  cur : UInt
  ankr : BytesView
}
pub fn KerxSubtables::iter(Self) -> Iter[KerxSubtable]

pub struct LookupData {
  index : UInt16
  stage : Byte
  kind : LookupKind
  mut feature : UInt16
  mask : Byte
  ignored : Byte
  is_ext : Bool
  offset : UInt
  mut coverage : UInt
  count : UInt16
  mut subtables : (UInt16, UInt16)
  mark_set : UInt
  mark_check : Byte
  mark_class : Byte
}
pub fn LookupData::set_coverage(Self, UInt) -> Unit
pub fn LookupData::set_feature(Self, UInt16) -> Unit
pub fn LookupData::set_subtables(Self, UInt16, UInt16) -> Unit
pub fn LookupData::subtable_data(Self, Bytes, UInt16) -> SubtableData?

pub(all) enum LookupKind {
  SingleSub
  MultiSub
  AltSub
  LigSub
  SingleAdj
  PairAdj
  Cursive
  MarkToBase
  MarkToLig
  MarkToMark
  Context
  ChainContext
  RevChainContext
}

pub struct Maxp {
  data : BytesView
}
pub fn[T : RawFont] Maxp::from_font(T) -> Self?
pub fn Maxp::glyph_count(Self) -> UInt
pub fn Maxp::is_truetype(Self) -> Bool
pub fn Maxp::max_component_depth(Self) -> UInt
pub fn Maxp::max_component_elements(Self) -> UInt
pub fn Maxp::max_composite_contours(Self) -> UInt
pub fn Maxp::max_composite_points(Self) -> UInt
pub fn Maxp::max_contours(Self) -> UInt
pub fn Maxp::max_function_definitions(Self) -> UInt
pub fn Maxp::max_instruction_definitions(Self) -> UInt
pub fn Maxp::max_instructions_size(Self) -> UInt
pub fn Maxp::max_points(Self) -> UInt
pub fn Maxp::max_stack_depth(Self) -> UInt
pub fn Maxp::max_storage(Self) -> UInt
pub fn Maxp::max_twilight_points(Self) -> UInt
pub fn Maxp::max_zones(Self) -> UInt
pub fn Maxp::new(BytesView) -> Self
pub fn Maxp::version(Self) -> UInt

pub struct MorxChain {
  b : BeBytes
  offset : Int
  default_flags : UInt
  feature_count : UInt
  subtable_count : UInt
}
pub fn MorxChain::default_flags(Self) -> UInt
pub fn MorxChain::features(Self) -> Iter[MorxFeature]
pub fn MorxChain::subtables(Self) -> MorxSubtables

pub struct MorxChains {
  b : BeBytes
  offset : Int
  len : UInt
  cur : UInt
}
pub fn MorxChains::iter(Self) -> Iter[MorxChain]

pub struct MorxContextual {
  b : BeBytes
  state_table : ExtendedStateTable
  table : Int
}
pub fn MorxContextual::next(Self, MorxContextualState, Int, UInt16, Bool, (Int, UInt16) -> Unit?) -> Unit?

type MorxContextualData

pub struct MorxContextualState {
  mut state : UInt16
  mut mark_set : Bool
  mut mark_index : Int
  mut mark_id : UInt16
}
pub fn MorxContextualState::new() -> Self

pub struct MorxFeature {
  selector : UInt16
  setting_selector : UInt16
  enable_flags : UInt
  disable_flags : UInt
}

pub struct MorxInsertion {
  b : BeBytes
  state_table : ExtendedStateTable
  action : Int
}
pub fn MorxInsertion::next(Self, MorxInsertionState, Int, UInt16, Bool, (Int, ArrayView[UInt16]) -> Unit?) -> Int?

type MorxInsertionData

pub struct MorxInsertionState {
  mut state : UInt16
  mut mark : Int
  mut cycles : Int
}
pub fn MorxInsertionState::new() -> Self

pub struct MorxLigature {
  b : BeBytes
  state_table : ExtendedStateTable
  action : Int
  component : Int
  ligature : Int
}
pub fn MorxLigature::next(Self, MorxLigatureState, Int, UInt16, Bool, (Int, UInt16, ArrayView[Int]) -> Unit?) -> Unit?

pub struct MorxLigatureState {
  mut state : UInt16
  indices : Array[Int]
  glyphs : Array[UInt16]
  mut pos : Int
}
pub fn MorxLigatureState::new() -> Self

pub struct MorxNonContextual {
  b : BeBytes
}
pub fn MorxNonContextual::substitute(Self, UInt16) -> UInt16?

pub struct MorxRearrange {
  l : Int
  r : Int
  reverse_l : Bool
  reverse_r : Bool
  start : Int
  end : Int
}
pub fn[T] MorxRearrange::apply(Self, Array[T]) -> Unit

pub struct MorxRearrangement {
  state_table : ExtendedStateTable
}
pub fn MorxRearrangement::next(Self, MorxRearrangementState, Int, UInt16, Bool, (MorxRearrange) -> Unit?) -> Int?

pub struct MorxRearrangementState {
  mut state : UInt16
  mut first : Int
  mut last : Int
  mut cycles : Int
}
pub fn MorxRearrangementState::new() -> Self

pub struct MorxSubtable {
  b : BeBytes
  offset : Int
  kind : UInt
  coverage : UInt
  flags : UInt
}
pub fn MorxSubtable::flags(Self) -> UInt
pub fn MorxSubtable::kind(Self) -> MorxSubtableKind?
pub fn MorxSubtable::should_reverse(Self, Bool) -> Bool

pub(all) enum MorxSubtableKind {
  Rearrangement(MorxRearrangement)
  Contextual(MorxContextual)
  Ligature(MorxLigature)
  NonContextual(MorxNonContextual)
  Insertion(MorxInsertion)
}

pub struct MorxSubtables {
  b : BeBytes
  offset : Int
  len : UInt
  cur : UInt
}
pub fn MorxSubtables::iter(Self) -> Iter[MorxSubtable]

pub struct Mvar {
  data : Bytes
  coords : ArrayView[Int]
  base : Int
  rec_size : Int
  rec_count : Int
  store : UInt
}
pub fn Mvar::delta(Self, UInt) -> Double
pub fn Mvar::new(Bytes, UInt, ArrayView[Int]) -> Self?

pub struct Os2 {
  data : BytesView
}
pub fn Os2::average_char_width(Self) -> Int
pub fn Os2::cap_height(Self) -> Int
pub fn[T : RawFont] Os2::from_font(T) -> Self?
pub fn Os2::new(BytesView) -> Self
pub fn Os2::selection_flags(Self) -> Os2Flags
pub fn Os2::strikeout_position(Self) -> Int
pub fn Os2::strikeout_size(Self) -> Int
pub fn Os2::typographic_ascender(Self) -> Int
pub fn Os2::typographic_descender(Self) -> Int
pub fn Os2::typographic_line_gap(Self) -> Int
pub fn Os2::version(Self) -> UInt
pub fn Os2::weight_class(Self) -> Int
pub fn Os2::width_class(Self) -> Int
pub fn Os2::x_height(Self) -> Int

pub struct Os2Flags {
  value : UInt
}
pub fn Os2Flags::italic(Self) -> Bool
pub fn Os2Flags::oblique(Self) -> Bool
pub fn Os2Flags::use_typographic_metrics(Self) -> Bool

pub struct Post {
  data : BytesView
}
pub fn Post::data(Self) -> BytesView
pub fn[T : RawFont] Post::from_font(T) -> Self?
pub fn Post::has_names(Self) -> Bool
pub fn Post::is_fixed_pitch(Self) -> Bool
pub fn Post::italic_angle(Self) -> UInt
pub fn Post::name(Self, UInt16) -> String?
pub fn Post::new(BytesView) -> Self
pub fn Post::underline_position(Self) -> Int
pub fn Post::underline_size(Self) -> Int
pub fn Post::version(Self) -> UInt

pub(all) struct StateTable {
  b : BeBytes
  class_count : Int
  state_array : Int
  states : BytesView
  entry_table : Int
  first_glyph : UInt16
  classes : BytesView
}
pub fn StateTable::class(Self, UInt16) -> UInt16
pub fn[T] StateTable::entry(Self, UInt16, UInt16, Int, (BeBytes, Int) -> T?) -> AatEntry[T]?
pub fn StateTable::new(BytesView) -> Self?

pub struct Stream {
  data : BytesView
  mut offset : Int
}
pub fn Stream::check_range(Self, Int) -> Bool
pub fn Stream::data(Self) -> BytesView
pub fn Stream::from_view(BytesView) -> Self
pub fn Stream::len(Self) -> Int
pub fn Stream::new(Bytes) -> Self
pub fn Stream::offset(Self) -> Int
pub fn Stream::read_i16(Self) -> Int?
pub fn Stream::read_u16(Self) -> UInt?
pub fn Stream::read_u32(Self) -> UInt?
pub fn Stream::read_u8(Self) -> Byte?
pub fn Stream::remaining(Self) -> Int
pub fn Stream::set_offset(Self, Int) -> Bool
pub fn Stream::skip(Self, Int) -> Bool
pub fn Stream::with_offset(Bytes, Int) -> Self?

pub struct SubtableData {
  offset : UInt
  kind : SubtableKind
  coverage : UInt16
}
pub fn SubtableData::coverage(Self, Bytes, UInt16) -> UInt16?

pub(all) enum SubtableKind {
  SingleSub1
  SingleSub2
  MultiSub1
  AltSub1
  LigSub1
  SingleAdj1
  SingleAdj2
  PairAdj1
  PairAdj2
  Cursive1
  MarkToBase1
  MarkToLig1
  MarkToMark1
  Context1
  Context2
  Context3
  ChainContext1
  ChainContext2
  ChainContext3
  RevChainContext1
}

pub struct Vhea {
  data : BytesView
}
pub fn Vhea::ascender(Self) -> Int
pub fn Vhea::descender(Self) -> Int
pub fn[T : RawFont] Vhea::from_font(T) -> Self?
pub fn Vhea::line_gap(Self) -> Int
pub fn Vhea::max_advance(Self) -> UInt
pub fn Vhea::new(BytesView) -> Self
pub fn Vhea::num_long_metrics(Self) -> UInt

// Type aliases
pub type RawTag = UInt

// Traits
pub(open) trait RawFont {
  data(Self) -> Bytes
  offset(Self) -> Int
}

